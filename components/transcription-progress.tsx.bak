'use client';

import { useState, useEffect } from 'react';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { CheckCircle2, AlertTriangle } from 'lucide-react';
import { WhisperTranscriptionProgressEvent } from '@/lib/knowledge/types/audio';

interface TranscriptionProgressProps {
  documentId: string;
  onCompleted?: (transcript: any) => void;
  onError?: (error: string) => void;
  pollingInterval?: number;
  maxAttempts?: number;
}

export function TranscriptionProgress({
  documentId,
  onCompleted,
  onError,
  pollingInterval = 2000, // Check every 2 seconds by default
  maxAttempts = 30 // Maximum number of polling attempts (60 seconds at 2000ms interval)
}: TranscriptionProgressProps) {
  const [progress, setProgress] = useState<number>(0);
  const [status, setStatus] = useState<'processing' | 'completed' | 'failed'>('processing');
  const [message, setMessage] = useState<string>('Transcription in progress...');
  const [error, setError] = useState<string | null>(null);
  const [partialTranscript, setPartialTranscript] = useState<string | null>(null);
  const [pollCount, setPollCount] = useState(0);
  
  useEffect(() => {
    let timeoutId: NodeJS.Timeout;
    let isMounted = true; // Flag to track if component is mounted
    
    const checkProgress = async () => {
      // Stop polling if we've reached the maximum number of attempts
      if (pollCount >= maxAttempts) {
        const errorMsg = 'Transcription timed out after maximum polling attempts';
        console.error(errorMsg);
        if (isMounted) {
          setError(errorMsg);
          setMessage('Transcription timed out');
          setStatus('failed');
          
          // Call onError if provided
          if (onError) {
            onError(errorMsg);
          }
        }
        return;
      }
      
      try {
        // Check if component is still mounted before making the request
        if (!isMounted) return;
        
        const response = await fetch(`/api/knowledge/${documentId}/transcription/progress`);
        
        // Check again if component is still mounted after the request
        if (!isMounted) return;
        
        if (!response.ok) {
          throw new Error(`Server returned ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json() as WhisperTranscriptionProgressEvent;
        
        // Update state based on response (only if component is still mounted)
        if (isMounted) {
          setStatus(data.status);
          setProgress(data.progress);
          
          if (data.error) {
            setError(data.error);
            setMessage('Transcription failed');
            
            // Call onError if provided
            if (onError) {
              onError(data.error);
            }
          } else if (data.message) {
            setMessage(data.message);
          }
          
          if (data.text) {
            setPartialTranscript(data.text);
          }
          
          // If completed, stop polling and call onCompleted
          if (data.status === 'completed') {
            if (onCompleted && data.transcript) {
              onCompleted(data.transcript);
            }
            return;
          }
          
          // Continue polling if still processing
          if (data.status === 'processing') {
            setPollCount(c => c + 1);
            timeoutId = setTimeout(checkProgress, pollingInterval);
          }
        }
      } catch (err) {
        // Only update state if component is still mounted
        if (isMounted) {
          console.error('Error checking transcription progress:', err);
          setError('Failed to check transcription progress');
          
          // Keep polling if there was an error, but less frequently
          setPollCount(c => c + 1);
          
          // After 10 failed attempts, slow down polling
          // But still respect the maximum attempts limit
          if (pollCount >= maxAttempts - 5) {
            // We're close to the max attempts, call onError
            if (onError) {
              onError('Transcription process appears to be failing');
            }
          }
          
          // Calculate next poll interval
          const nextInterval = pollCount > 10 ? pollingInterval * 2 : pollingInterval;
          
          // Only set timeout if we haven't reached max attempts
          if (pollCount < maxAttempts) {
            timeoutId = setTimeout(checkProgress, nextInterval);
          }
        }
      }
    };
    
    // Start polling
    checkProgress();
    
    // Clean up timeout on unmount
    return () => {
      // Mark component as unmounted to prevent state updates after unmount
      isMounted = false;
      
      // Clear any pending timeouts
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
    };
  }, [documentId, pollingInterval, pollCount, onCompleted, onError, maxAttempts]);
  
  return (
    <div className="space-y-4 py-2">
      <div className="flex items-center justify-between mb-2">
        <div className="flex items-center gap-3">
          {status === 'processing' && (
            <div className="animate-spin h-5 w-5 border-b-2 border-hunter_green-500 dark:border-asparagus-500 rounded-full"></div>
          )}
          
          {status === 'completed' && (
            <CheckCircle2 className="h-5 w-5 text-hunter_green-500 dark:text-asparagus-500" />
          )}
          
          {status === 'failed' && (
            <AlertTriangle className="h-5 w-5 text-tigers_eye-500" />
          )}
          
          <span className="font-medium text-hunter_green-600 dark:text-cornsilk-400">{message}</span>
        </div>
        
        {/* Show poll count */}
        <span className="text-xs text-muted-foreground">
          Attempt {pollCount}/{maxAttempts}
        </span>
      </div>
      
      {/* Custom progress bar */}
      <div className="h-2 w-full bg-cornsilk-400 dark:bg-hunter_green-300 rounded-full overflow-hidden">
        <div 
          className="h-full bg-hunter_green-500 dark:bg-asparagus-500 transition-all"
          style={{ width: `${progress}%` }}
        ></div>
      </div>
      
      {partialTranscript && (
        <div className="mt-4">
          <h4 className="text-sm font-medium text-hunter_green-500 dark:text-cornsilk-500 mb-1">
            Partial transcript:
          </h4>
          <div className="bg-cornsilk-600 dark:bg-hunter_green-400 rounded p-3 text-sm text-hunter_green-600 dark:text-cornsilk-400">
            {partialTranscript}
          </div>
        </div>
      )}
      
      {error && (
        <Alert variant="destructive" className="mt-4 bg-tigers_eye-100 dark:bg-tigers_eye-900 border-tigers_eye-300 dark:border-tigers_eye-700">
          <AlertDescription className="text-tigers_eye-600 dark:text-tigers_eye-300">{error}</AlertDescription>
        </Alert>
      )}
    </div>
  );
}